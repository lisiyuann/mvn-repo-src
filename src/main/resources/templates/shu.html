<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>数据结构知识点管理系统</title>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config" th:inline="none">
        MathJax.Hub.Config({
	    tex2jax: {
	        inlineMath: [['$','$'], ['\\(','\\)']],
	        processEscapes: true
	    }
	});
    </script>
</head>
<body>
<h2 style="text-align:center">树相关知识点<h2>

    <div>
        <form action="/zhuye" method="post">

            <input type="submit" value="返回主页">
        </form>
    </div>



    <div class="content">
        <h3>1.1二叉树基本概念</h3>
            <p>含n个结点的完全二叉树的深度为：$d=log_{2}n+1$ ;
                <br>&nbsp; &nbsp; &nbsp; &nbsp; 查找成功时的比较次数至多为：$log_{2}n+1$ ；
                <br>&nbsp; &nbsp; &nbsp; &nbsp; 查找成功时比较次数，为该节点在判定树上的层次数，不超过树的深度 。
            </p>
            <p>二叉链表的定义:
                <br>&nbsp; &nbsp; &nbsp; &nbsp; Typedef struct
                <br>&nbsp; &nbsp; &nbsp; &nbsp; {
                <br>&nbsp; &nbsp; &nbsp; &nbsp; keyType Key;
                <br>&nbsp; &nbsp; &nbsp; &nbsp; Info type otherinfo;
                <br>&nbsp; &nbsp; &nbsp; &nbsp; }TElemType;
            </p>
        <h3>1.2平衡二叉树</h3>
            <p>平衡二叉树创建方法：
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （1）插入新结点的时候，按照二叉排序树来进行处理；
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （2）若插入的结点破坏了平衡二叉树的特性，就需要对平衡二叉树进行调整。
            </p>
            <p>平衡二叉树调整方法：找到离插入结点最近且平衡因子绝对值超过1的祖先结点，以该节点为艮的子树为最小补平衡树，可将重新平衡的范围局限于这棵子树。</p>
        <h3>1.3 顺序查找、折半查找、二叉排序树查找共同特点</h3>
            <p><br>&nbsp; &nbsp; &nbsp; &nbsp; （1）需要经过系列的比较来确定关键字key的记录在表中的“地址”；
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （2）若平均查找长度都不为0；
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （3）不同查找方法仅在关键字和给定值进行比较的顺序不同。
            </p>
        <h3>2.1哈夫曼树基本概念</h3>
            <p> 树的带权路径长度（WPL）：根到每个叶结点的路径长度和该叶结点权值的乘积。一颗有n个叶结点的二叉树，每个叶子节点带有权值Wi，从根节点到每个叶结点的路径长度为Li，则树的带权路径长度WPL为： </p>
            <p style="text-align: center; ">$WPL=\sum_{i-1}^{n}W_{i}l_{i}$</p>
            <p>哈夫曼树就是使WPL值最小的二叉树。</p>
        <h3>2.2哈夫曼树的构造方法</h3>
            <p> 核心思想：每次把根节点权值最小的两颗二叉树合并。
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （1）将权值从小到大排序；
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （2）将权值最小的两个结点合并，新结点权值为所合并的两个结点权值之和，得到一棵新二叉树；
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （3）重复步骤（1）、（2），直到只剩下一棵二叉树；</p>
            <p>因此，就得到一颗哈夫曼树，如下图1.1所示。</p>
            <img src="../static/1.jpg" width="400" height="300" alt=" ">
        <h3>2.3哈夫曼树相关结论</h3>
            <p><br>&nbsp; &nbsp; &nbsp; &nbsp; （1）哈夫曼树并不唯一；
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （2）哈夫曼树的子树也是哈夫曼树；
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （3）哈夫曼树中无度为1的结点；
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （4）有n个叶子结点的哈夫曼树，其总结点树为2n-1；
        <h3>2.4哈夫曼编码</h3>
            <p>在电文传输中，需要将电文中出现的每个字符进行二进制编码。在设计编码时需要遵守两个原则：
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （1）发送方传输的二进制编码，到接收方解码后必须具有唯一性，即解码结果与发送方发送的电文完全一样；
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （2）发送的二进制编码尽可能地短。下面我们介绍两种编码的方式。</p>
            <p>①等长编码</p>
            <p>这种编码方式的特点是每个字符的编码长度相同（编码长度就是每个编码所含的二进制位数）。假设字符集只含有4个字符A，B，C，D，用二进制两位表示的编码分别为00，01，10，11。若现在有一段电文为：ABACCDA，则应发送二进制序列：00010010101100，总长度为14位。当接收方接收到这段电文后，将按两位一段进行译码。这种编码的特点是译码简单且具有唯一性，但编码长度并不是最短的。</p>
            <p>②不等长编码</p>
            <p>在传送电文时，为了使其二进制位数尽可能地少，可以将每个字符的编码设计为不等长的，使用频度较高的字符分配一个相对比较短的编码，使用频度较低的字符分配一个比较长的编码。例如，可以为A，B，C，D四个字符分别分配0，00，1，01，并可将上述电文用二进制序列：000011010发送，其长度只有9个二进制位，但随之带来了一个问题，接收方接到这段电文后无法进行译码，因为无法断定前面4个0是4个A，1个B、2个A，还是2个B，即译码不唯一，因此这种编码方法不可使用。</p>
            <p>因此，为了设计长短不等的编码，以便减少电文的总长，还必须考虑编码的唯一性，即在建立不等长编码时必须使任何一个字符的编码都不是另一个字符的前缀，这种编码称为前缀编码（prefix  code）：
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （1）利用字符集中每个字符的使用频率作为权值构造一个哈夫曼树；
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （2）从根结点开始，为到每个叶子结点路径上的左分支赋予0，右分支赋予1，并从根到叶子方向形成该叶子结点的编码。</p>
             <p>例：
            假设一个文本文件TFile中只包含7个字符{A，B，C，D，E，F，G}，这7个字符在文本中出现的次数为{5，24，7，17，34，5，13}
            利用哈夫曼树可以为文件TFile构造出符合前缀编码要求的不等长编码
            </p>
            <p> 具体做法：
            <br>&nbsp; &nbsp; &nbsp; &nbsp; （1）将TFile中7个字符都作为叶子结点，每个字符出现次数作为该叶子结点的权值；
            <br>&nbsp; &nbsp; &nbsp; &nbsp; （2）规定哈夫曼树中所有左分支表示字符0，所有右分支表示字符1,将依次从根结点到每个叶子结点所经过的分支的二进制位的序列作为该结点对应的字符编码；
            <br>&nbsp; &nbsp; &nbsp; &nbsp; （3）由于从根结点到任何一个叶子结点都不可能经过其他叶子，这种编码一定是前缀编码，哈夫曼树的带权路径长度正好是文件TFile编码的总长度。
            <br>&nbsp; &nbsp; &nbsp; &nbsp; 通过哈夫曼树来构造的编码称为哈弗曼编码（huffman code），如下图1.2所示。</p>
            <img src="../static/2.jpg" width="400" height="300" alt=" ">
        <h3>普利姆最小生成树方法（Prim算法）</h3><br>
        <h3>3.1Prim算法基本思想</h3>
            <p><br>&nbsp; &nbsp; &nbsp; &nbsp; （1）将图中的顶点分成两个不同的顶点集S与V-S，将初始点加入到S集中；
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （2）在横跨两个不同顶点集的边中选择一条权值最小的边加入到生成树中；
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （3）将该边的另一点加入到顶点集S中，并从V-S中删除；
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （4）重复步骤2-3，直到V-S为空。
            </p>
        <h3>3.2Prim算法边的选择</h3>
            <p><br>&nbsp; &nbsp; &nbsp; &nbsp; （1）设置数组[closest[j]]；
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （2）j属于V-S顶点集中的顶点；
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （3）定义[closest[j]为j在S中的一个邻接点，且j到[closest[j]的距离最小。
                <br>&nbsp; &nbsp; &nbsp; &nbsp; j∈V-S;
                <br>&nbsp; &nbsp; &nbsp; &nbsp; closest[j]∈S;
                <br>&nbsp; &nbsp; &nbsp; &nbsp; Cost(j,closest[j]) = min{cost(j,i)} (i∈S);
            </p>
        <h3>3.3Prim算法的基本步骤</h3>
            <p><br>&nbsp; &nbsp; &nbsp; &nbsp; （1）划分顶点集为S何V-S；
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （2）对于j∈V-S，定义closest[j]={k|min{c[i][k]|k∈S,j∈V-S}};
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （3）选择：针对k∈V-S，选择j={k|min{c[k][closest[k]]}};
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （4）修改：针对k∈V-S，修改其为closest[k];
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （5）重复3-4步骤，直到V-S=φ。
            </p>
        <h3>3.4Prim算法的初始化</h3>
            <p><br>&nbsp; &nbsp; &nbsp; &nbsp; （1）除出发点V外，其余顶点均在V-S集中；
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （2）其余顶点的closest值均为出发点V;
                <br>&nbsp; &nbsp; &nbsp; &nbsp; for(i=1;i<=n;i++)
                <br>&nbsp; &nbsp; &nbsp; &nbsp; {
                <br>&nbsp; &nbsp; &nbsp; &nbsp; s[i]=0;
                <br>&nbsp; &nbsp; &nbsp; &nbsp; closest[i]=v;
                <br>&nbsp; &nbsp; &nbsp; &nbsp;  }
                <br>&nbsp; &nbsp; &nbsp; &nbsp; s[v]=1;
            </p>
        <h3>3.5Prim算法的描述</h3>
            <p><br>&nbsp; &nbsp; &nbsp; &nbsp; （1）初始化；
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （2）边选择；
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （3）修改数组；
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （4）重复步骤2~3，直到s数组全为1。</p>
        <h3>克鲁斯卡尔最小生成树算法（Kruskal算法）</h3>
        <h3>4.1 Kruskal算法基本思想</h3>
            <p><br>&nbsp; &nbsp; &nbsp; &nbsp; （1）把图中的顶点看成n个不同的顶点集，每个顶点集都只含有1个顶点；
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （2）每次都在横跨不同顶点集的边中选择一条权值最小的边加入到最小生成树中；
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （3）直到图中所有的顶点都在同一个顶点集中为止。
            </p>
        <h3>4.2 Kruskal算法求解思路</h3>
            <p><br>&nbsp; &nbsp; &nbsp; &nbsp; （1）连通图的边按照权值从小到大进行排列；
                <br>&nbsp; &nbsp; &nbsp; &nbsp; （2）依次检查它的每条边对应的两个端点是否分别属于两个不同的顶点集，是，则加入生成树中，不是，则不加入生成树中。
            </p>






    </div>









</body>

<style>
    .knowledge li{
        display:inline-block;
        margin: 0 30px 0 0;
        /*display: block;*/
        /*position: relative;*/
        /*text-align: center;*/
        /*display: flex;*/
        /*justify-content: center;*/
    }
    /*h2{*/
    /*    display: flex;*/
    /*    justify-content: center;*/
    /*}*/
    .content{
        text-indent:5em;

        white-space:normal;
        word-wrap:break-word;
        word-break:break-all;
    }
    h3{
        font-size:20px;
        text-indent:5em;
        line-height:0.1px;
        white-space:normal;
        word-wrap:break-word;
        word-break:break-all;

    }
    br{
        padding-left:8em;
        padding-right:6em;
        margin-block-start:2em;
        margin-block-end: 2em;
        margin-inline-start: 0px;
        margin-inline-end: 0px;
    }

    p,img{
        font-size:16px;
        display:inline;
        text-indent:2em;
        padding-left:6em;
        padding-right:6em;
        white-space:normal;
        word-wrap:break-word;
        word-break:break-all;




        /*border: solid 1px gray!**!;*/

        display: block;
        margin-block-start:1em;
        margin-block-end: 1em;
        margin-inline-start: 0px;
        margin-inline-end: 0px;
        font-family: "Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
        orphans: 4;
        text-align: start;
        /*white-space: pre-wrap;*/


    }


</style>


</html>